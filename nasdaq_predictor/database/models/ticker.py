"""
Ticker model for NQP application.

This module defines the Ticker dataclass that represents ticker symbols
and their metadata in the database.
"""

from dataclasses import dataclass, field, asdict
from datetime import datetime, time
from typing import Optional, Dict, Any
from enum import Enum


class TickerType(Enum):
    """Enum for ticker types."""
    FUTURES = 'futures'
    INDEX = 'index'
    STOCK = 'stock'
    ETF = 'etf'


@dataclass
class Ticker:
    """
    Ticker dataclass representing a ticker symbol and its metadata.

    Attributes:
        id: Unique identifier (UUID)
        symbol: Ticker symbol (e.g., 'NQ=F', 'ES=F')
        name: Full name of the ticker
        type: Type of ticker (futures, index, stock, etf)
        enabled: Whether the ticker is enabled for data collection
        trading_hours_start: Start of trading hours (optional)
        trading_hours_end: End of trading hours (optional)
        timezone: Timezone for trading hours
        metadata: Additional metadata as JSON
        created_at: When the ticker was created
        updated_at: When the ticker was last updated
    """
    symbol: str
    name: str
    type: str  # TickerType enum value
    enabled: bool = True
    id: Optional[str] = None
    trading_hours_start: Optional[time] = None
    trading_hours_end: Optional[time] = None
    timezone: str = 'UTC'
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def __post_init__(self):
        """Validate ticker data after initialization."""
        # Validate ticker type
        if self.type not in [t.value for t in TickerType]:
            raise ValueError(
                f"Invalid ticker type: {self.type}. "
                f"Must be one of: {[t.value for t in TickerType]}"
            )

        # Validate symbol is not empty
        if not self.symbol or not self.symbol.strip():
            raise ValueError("Ticker symbol cannot be empty")

        # Validate name is not empty
        if not self.name or not self.name.strip():
            raise ValueError("Ticker name cannot be empty")

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Ticker':
        """
        Create a Ticker instance from a dictionary.

        Args:
            data: Dictionary containing ticker data

        Returns:
            Ticker: Ticker instance

        Example:
            >>> data = {'symbol': 'NQ=F', 'name': 'NASDAQ-100 Futures', 'type': 'futures'}
            >>> ticker = Ticker.from_dict(data)
        """
        # Handle datetime strings
        if 'created_at' in data and isinstance(data['created_at'], str):
            data['created_at'] = datetime.fromisoformat(data['created_at'].replace('Z', '+00:00'))

        if 'updated_at' in data and isinstance(data['updated_at'], str):
            data['updated_at'] = datetime.fromisoformat(data['updated_at'].replace('Z', '+00:00'))

        # Handle time strings
        if 'trading_hours_start' in data and isinstance(data['trading_hours_start'], str):
            data['trading_hours_start'] = datetime.strptime(
                data['trading_hours_start'], '%H:%M:%S'
            ).time()

        if 'trading_hours_end' in data and isinstance(data['trading_hours_end'], str):
            data['trading_hours_end'] = datetime.strptime(
                data['trading_hours_end'], '%H:%M:%S'
            ).time()

        return cls(**data)

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert Ticker instance to a dictionary.

        Returns:
            Dict[str, Any]: Dictionary representation of the ticker

        Example:
            >>> ticker = Ticker(symbol='NQ=F', name='NASDAQ-100 Futures', type='futures')
            >>> data = ticker.to_dict()
        """
        data = asdict(self)

        # Convert datetime to ISO format strings
        if self.created_at:
            data['created_at'] = self.created_at.isoformat()

        if self.updated_at:
            data['updated_at'] = self.updated_at.isoformat()

        # Convert time to string format
        if self.trading_hours_start:
            data['trading_hours_start'] = self.trading_hours_start.strftime('%H:%M:%S')

        if self.trading_hours_end:
            data['trading_hours_end'] = self.trading_hours_end.strftime('%H:%M:%S')

        return data

    def to_db_dict(self) -> Dict[str, Any]:
        """
        Convert Ticker instance to a dictionary for database insertion.
        Excludes id, created_at, and updated_at fields.

        Returns:
            Dict[str, Any]: Dictionary for database insertion
        """
        data = self.to_dict()

        # Remove fields that are auto-generated by the database
        data.pop('id', None)
        data.pop('created_at', None)
        data.pop('updated_at', None)

        return data

    def is_futures(self) -> bool:
        """Check if ticker is a futures contract."""
        return self.type == TickerType.FUTURES.value

    def is_index(self) -> bool:
        """Check if ticker is an index."""
        return self.type == TickerType.INDEX.value

    def is_stock(self) -> bool:
        """Check if ticker is a stock."""
        return self.type == TickerType.STOCK.value

    def is_etf(self) -> bool:
        """Check if ticker is an ETF."""
        return self.type == TickerType.ETF.value

    def has_trading_hours(self) -> bool:
        """Check if ticker has defined trading hours."""
        return self.trading_hours_start is not None and self.trading_hours_end is not None

    def __repr__(self) -> str:
        """String representation of Ticker."""
        return (
            f"<Ticker symbol={self.symbol} name={self.name} "
            f"type={self.type} enabled={self.enabled}>"
        )

    def __str__(self) -> str:
        """Human-readable string representation."""
        status = "enabled" if self.enabled else "disabled"
        return f"{self.symbol} ({self.name}) - {self.type} [{status}]"
